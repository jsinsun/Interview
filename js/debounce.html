<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <div>isUpgrade 比较版本号</div>
    <div>
      <p>防抖（debounce）:当持续触发事件时，保证只执行最后一次事件处理函数</p>
      <button id="debounce">防抖</button>
    </div>

    <div>
      <p>
        节流（throttle）当持续触发事件时，保证一定时间段内只调用一次事件处理函数
      </p>
      <button id="throttle">节流</button>
    </div>
  </body>
</html>

<script>
  function isUpgrade(current_version, compare_version = "6.0.0.0") {
    var compare_version_array = compare_version.split(".");
    var current_version_array = current_version.split(".");
    var is_upgrade = true;
    if (
      compare_version_array.length == 4 &&
      current_version_array.length == 4
    ) {
      for (var i = 0; i < compare_version_array.length; i++) {
        if (
          parseInt(compare_version_array[i]) <
          parseInt(current_version_array[i])
        ) {
          is_upgrade = true;
          break;
        } else {
          if (
            parseInt(compare_version_array[i]) ===
            parseInt(current_version_array[i])
          ) {
            continue;
          } else {
            is_upgrade = false;
            break;
          }
        }
      }
    }
    return is_upgrade;
  }

  // 防抖

  function debounce(fn) {
    let timeout = null; // 创建一个标记用来存放定时器的返回值
    return function () {
      clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉
      timeout = setTimeout(() => {
        // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数
        fn();
      }, 500);
    };
  }
  function sayHi() {
    console.log("防抖成功");
  }
  let box = document.getElementById("box");
  box.addEventListener("click", debounce(sayHi));


  function throttle(fn) {
    let canRun = true; // 通过闭包保存一个标记
    return function () {
      if (!canRun) return; // 在函数开头判断标记是否为true，不为true则return
      canRun = false; // 立即设置为false
      setTimeout(() => {
        // 将外部传入的函数的执行放在setTimeout中
        fn();
        // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。当定时器没有执行的时候标记永远是false，在开头被return掉
        canRun = true;
      }, 500);
    };
  }
  
  function sayHi(e) {
    console.log("节流");
  }
  window.addEventListener("resize", throttle(sayHi));
</script>
